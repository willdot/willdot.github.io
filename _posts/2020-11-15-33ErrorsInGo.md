---
title:  Errors in Go
author: Will Andrews
date: 2020-11-15
order: 33
published: true
---

Go has a very idiomatic way of error handling. Functions return an error and the first thing you should do when receiving the result of a function, is check the error and handle it. Handling it usually means logging it or adding more context to the error by wrapping it and then returning it to the calling function, and so on. It usually looks a little like this (and those that know Go, will probably write the `if err != nil`  this in their sleep).

``` go
func makeSomethingGoWrong() error {
    return errors.New("this went terribly wrong")
}

func main() {
    err := makeSomethingGoWrong()
    if err != nil {
        log.Print(err.Error())
    }
}
```

### Wrapping errors with more context

Sometimes when a function receives an error, and that function will then call it to it's calling function, adding some context as to which part of the function failed might help working out what and where something went wrong.

For example, a function makes a call to a database and it fails but the error that is returned is a generic `connection timeout` error. This might not be that useful to the caller. So adding some extra context to the error to say `error getting record with ID: '123'`. Now the caller has more context about what was being tried.

This can be done using the wrap function.

``` go
id := "123"
err := saveRecord(id)
if err != nil {
    return errors.Wrapf(err, "error getting record '%s'", id)
}
```

### Finding the root error
In the `pkg/errors` package each time `errors.Wrap()` is called, a new error is returned. That new error stores the first error in a cause field. This means that if `errors.Wrap()` is used on any error, the wrapped error can be retrieved by calling `err.Cause()`.

What if the error has been wrapped 3 times? Calling `err.Cause()` would only get the last error that was wrapped, but not the first. To get the first error that was wrapped on the chain, the function `errors.Cause(err)` can be used. This will in essence run a loop, checking if the error implements the `Cause() error` function and if it does, get the cause error. Then keep going until the error doesn't implement that interface, indicating that it was the first error that was wrapped. The source code can be found [here](https://github.com/pkg/errors/blob/614d223910a179a466c1767a985424175c39b465/errors.go#L275)

This will allow us to find out the root error in the chain of wrapped errors. 


I recently wrote some code for a service that wrote files to Gluster. However if the directory doesn't exist that the file needs to be written to, an `os.PathError` would be returned. In this scenario, we would then create the directory and try again. To do this, I can check the error that was returned from the Gluster API using `errors.Cause()`.

``` go
func writeFileToGluster(filePath string, body []byte) error {
    err := gluster.WriteFile(filePath, body)
    // if the cause of the error is not a path error then return it
    if _, ok := errors.Cause(err).(*os.PathError); !ok {
        return errors.Wrapf(err, "error saving file at path '%s'", filePath)
    }
    // create the directory and try again
    // ...
    return nil
}
```

Here I am getting the root error and then checking if it's of type `os.PathError`. This will tell me that the reason why saving the file failed, was because of a path error, likely that it didn't exist.

